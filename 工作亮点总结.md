## 异步转同步

> 第三方API调用

## Mysql 和 Redis 数据同步

>  binlong 分析同步到 Redis

## 多线程初始化缓存

> 应用启动，多线程初始化缓存

## 秒杀系统



## 高并发场景中内存的优化



## 高并发处理文本，防止GC 导致卡死

如果有一个微服务是处理大量的文本，感觉这种一般不会要求时延，大部分都会进行异步处理，更加注重服务的吞吐率。

服务可以在更大的内存服务器进行部署，然后把新生代的eden设置的更大些，因为这些文本处理完不会再拿来复用，朝生夕灭，可以在新生代Minor GC，防止对象晋升到老年代，防止频繁的Major GC，

如果晋升的对象过多大于老年代的连续内存空间也会有触发Full Gc，然后在这些处理文本的业务流程中，防止频繁的创建一次性的大对象，把文本对象做为业务流程直接传递下去，如果这些文本需要复用可以将他保存起来，防止频繁的创建。

也为了保证服务的高可用，也需对服务做限流、负载、兜底的一些策略。

