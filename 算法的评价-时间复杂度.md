## 算法复杂度分析场景

给你一个问题，给出算法，更具算法分析复杂度

如果正确，问你是否有改进的空间

## 复杂度分析方法

事前评价算法的好坏

执行的效率，随着数据量的增加，算法执行的时间的变化趋势

如果随着数据规模的增加，算法执行的时间急剧增加，那就不是一个好的算法；

这种特性可以使用函数的斜率表示，所以算法的复杂性都是使用函数表示的；

$n^2$ ， n*$\ln n$，n, $\ln n$



---

根据算法的表达，估计算法最主要部分执行的次数和数据规模之间的关系



``` java 
int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i; // 这行代码至少执行n次
   }
   return sum;
}
```

所以这个代码或者算法的时间复杂度的表示就是n

关于算法的中的时间复杂度的理解，时间为什么还有复杂度，我们直接理解就是算法执行的时间；`所以其中肯定是有其他的知识`, 所以还是留到下一轮处理吧

## 算法复杂度分析方法

### 看主要的循环

### 选择两级最大的

### 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

代码嵌套，要将内外算法的复杂度相乘

> 重点是多看，多练，例如： [从经典算法题看时间复杂度](http://jalan.space/2019/07/13/2019/time-complexity/) 常见的算法复杂度分析距离、函数、对数等基础数学知识有涉及

- 算法的复杂度还是分为多项式和非多项式，非多项式的咱不用考虑

- 常数级算法复杂度，一般是和数据规模n没有关系的操作，不管有多少次操作都记为O(1),

- 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

##  多个数据规模影响算法复杂度，不能随便省略



## 数据结构和算法现实中的例子

https://zhuanlan.zhihu.com/p/88992004  图书馆例子

## 算法执行效率影像的因素

https://www.zhihu.com/question/20196775/answer/154922935  如何清晰的理解算法中的时间复杂度？ [蔡先生](https://www.zhihu.com/people/cai-zhi-xiang)



## 计算的算法例子，理解时间复杂度重要性

https://zhuanlan.zhihu.com/p/71897038 通过线性搜索和二分搜索算法对比操作次数的差异，将算法时间复杂度具体化

## 算法复杂度的基本理解

简单理解： 算法的复杂度 = 粗略估计算法的执行时间 = 算法中执行`步骤数`或者`操作次数`

估算的方法：假设算法的程序中程序每个语句执行的时间是相等的，根据观察计算执行`步骤`,这个步骤数通常是和问题的规模或者数据的规模相关，所以算法的复杂度或者的执行时间是和数据规模相关的函数。

## 平均时间复杂度

是相对最好或者最好时间复杂度

在各种情况下的一种平均时间复杂度 = 平均算法操作数

基本是要用到概率，每种情况出现的概率；

平均时间复杂度 = 概率1 * *操作数 +概率2* * 操作数

这个值就是概率论中的加**权平均值**，也叫作**期望值**，所以**平均时间复杂度**的全称应该叫**加权平均时间复杂度或者期望时间复杂度**。



## 均摊时间复杂度

对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度

## 练习题

来分析一下下面这个 add() 函数的时间复杂度。

```java

// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
```

 总结分析

最好是O(1)，最差是O(n), 均摊是O(1)

## 总结

从算法的时间复杂度是用来干什么的？

事前估算算法的执行效率

张什么样子？

T(n) = O(f(n))

从实际的例子出发

从for循环求和实例，推导时间复杂度；忽略低阶，选取高阶

推导算法对应的时间复杂

通过各种典型的程序实例，推导时间复杂度；加法法则，乘法法则等

对通过算法的复杂度总结

## 参考

- [如何理解算法时间复杂度的表示法，例如 O(n²)、O(n)、O(1)、O(nlogn) 等](https://www.zhihu.com/question/21387264) 公式多多、题目看不懂、公式看不懂，还是先不看了，先搞懂基础的，等着再来一遍
- [从经典算法题看时间复杂度](http://jalan.space/2019/07/13/2019/time-complexity/) 常见的算法复杂度分析距离、函数、对数等基础数学知识有涉及
- [和程序员小吴一起学算法](https://www.cxyxiaowu.com/) 更加通俗的算法讲述、重点是想通过动画的形式表达算法的过程































